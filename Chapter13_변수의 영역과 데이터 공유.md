# 13.변수의 영역과 데이터 공유
## 13-1. 변수 사용 영역

#### 지역 변수
- 지금까지 사용했던 변수 : 지역 변수 (local variable)
- 원래 auto 예약어와 함께 함수 안에 지역 변수를 선언하나, auto는 생략이 가능하므로 함수 안에 선언된 변수는 자동으로 지역 변수가 됨
- 지역 변수 = 자동 변수 (local variable)
- 함수의 매개변수도 모두 지역 변수!

<지역 변수의 특징>
- 지역 변수는 사용 범위가 블록 내부로 제한되므로 다른 함수에서는 사용할 수 없다.
<br> -> 즉, 다른 함수에 같은 이름의 변수를 선언해도 이름이 서로 충돌하지 않는다.
- 지역 변수는 이름이 같아도 선언된 함수가 다르면, 각각 독립된 저장 공간을 갖는다.

<지역 변수 사용의 장점>
- 메모리를 효율적으로 사용한다.
<br> -> 운영체제는 지역 변수가 선언된 함수가 반환되면 할당된 저장 공간을 자동으로 회수하여 재활용한다.
디버깅에 유리하다.
<br> -> 지역 변수는 값에 문제가 있을 때 수정하기 쉽다.
	
<지역 변수 사용의 단점>
- 지역 변수가 할당된 저장 공간은  자동으로 초기화되지 않으므로, 쓰레기 값이 사용되지 않도록 주의해야한다. (장점의 1번이랑 차이가 아직 와닿지 않음)
<br> -- 지역변수 사용이 끝나면 지역변수의 장점 1에 의해 저장 공간이 반환되나, 값은 그대로 남아 있음!
- 사용 범위가 하나의 함수로 제한되므로 2개 이상의 함수에서 데이터를 공유하기가 쉽지 않다.

````C
#include <stdio.h>

void assign(void);        // 함수 선언

int main(void) {

	int a = 0;           // 책에는 auto int라 써도 되는 것처럼 나오지만, 오류가 뜬다! 왜지?

	assign();           // 함수 호출
	printf("main 함수 a : %d\n", a);

	return 0;
}

void assign(void) {

	int a;                 // main 함수에 있는 변수와 같은 이름의 지역 변수, auto 생략

	a = 10;             // assign 함수 안에 선언된 a에 대입
	printf("assign 함수 a : %d\n", a);    // assign 함수에 선언된 a 값 출력

}
````
````
assign 함수 a : 10
main 함수 a : 0
````

## 블록 안에서 사용하는 지역 변수
- 규칙 1 : 특정 블록 안에 변수를 선언하면 사용 범위가 블록 내부로 제한된다.
<br> -> 지역 변수가 사용한 메모리는 블록이 끝나면 동시에 반환된다..!!
- 규칙 2: 사용 가능한 변수가 둘 이상이면 가장 가까운 블록에 선언된 변수를 사용한다.
````C

#include <stdio.h>

int main(void) {

	int a = 10, b = 20;

	printf("교환 전 a와 b의 값 : %d, %d\n", a, b);
	{                                   // 블록 시작
		int temp;          // temp 변수 선언. 
                                               // 규칙1에 따라 temp 변수는 이 블록안에서만 사용 가능
		temp = a;
		a = b;              // a와 b는 5행에 선언된 변수
		b = temp;
	}                                  // 블록 끝
	printf("교환 후 a와 b의 값 : %d, %d\n", a, b); 
                                                         // 규칙2에 의해 a, b의 값은 바로 위 블럭에 영향 받음

	return 0;
}
````
````
교환 전 a와 b의 값 : 10, 20
교환 후 a와 b의 값 : 20, 10
````
#### 전역 변수
- 전역 변수 (global variable) : 함수 밖에 선언된 변수로 특정 함수의 블록에 포함되지 않으므로 사용 범위가 함수나 블록에 제한되지 않음

- 전역 변수는 특별한 값으로 초기화하지 않아도 0으로 자동으로 초기화됨(지역변수와의 차이점)

- 전역 변수와 같은 이름의 지역 변수가 있을 때 지역 변수를 먼저 사용함

<전역 변수의 문제점>
1. 전역 변수의 이름을 바꾸면 그 변수를 사용하는 모든 함수를 찾아 수정해야 한다,
2. 전역 변수의 값이 잘못된 경우 접근 가능한 모든 함수를 의심해야 한다.
3. 코드 블록 내에 같은 이름의 지역 변수를 선언하면 그 영역에서는 전역 변수를 사용할 수 없다.

결론 : 
사용 범위가 명확하고 통제 가능한 지역 변수를 우선적으로 사용하며 전역 변수는 많은 함수에서 수시로 데이터를 공유하는 경우 
<br>제한적으로 사용하는 것이 좋다.
````C

#include <stdio.h>

void assign10(void);
void assign20(void);

int a;                                 // 전역 변수 선언

int main(void) {

	printf("함수 호출 전 a 값 : %d\n", a);            // 전역 변수 a 출력

	assign10();
	assign20();

	printf("함수 호출 후 a 값 : %d\n", a);            // 전역 변수 a 출력

	return 0;
}

void assign10(void) {

	a = 10;                 // 전역 변수 a에 10 대입
}

void assign20(void) {

	int a;                    // 전역 변수와 같은 이름의 지역 변수 선언
	a = 20;                // 지역 변수 a에 20 대입
}
````
````
함수 호출 전 a 값 : 0
함수 호출 후 a 값 : 10
````
#### 정적 지역 변수
- 정적 지역 변수 (static variable) : 지역 변수를 선언할 때 static 예약어를 사용하면 지정됨.

- 지역변수와 코드 블록 안에 선언하므로 사용 범위가 블록 내부로 제한되는 것
은 동일하나,
<br>저장 공간이 메모리에 존재하는 기간이 다르며, 0으로 자동으로 초기화됨.
<br>-> 선언된 함수가 반환되더라도 그 저장 공간을 계속 유지한다.
<br>
- 따라서, 정적 지역 변수로 하나의 함수가 여러 번 호출되는 경우 같은 변수를 공유하는 것이 가능해짐!!
<br> Ex. 정적 지역 변수를 사용한 단어 분리 함수 구현이 가능해진다.!!

````C
#include <stdio.h>

void auto_func(void);
void static_func(void);

int main(void) {
	int i;
	
	printf("일반 지역 변수(auto)를 사용한 함수...\n");
	for (i = 0; i < 3; i++) {
		
		auto_func();
	}
	
	printf("정적 지역 변수(static)를 사용한 함수...\n");
	for (i = 0; i < 3; i++) {
		
		static_func();
	}

	return 0;
}

void auto_func(void) {
	int a = 0;            // 지역 변수 선언과 초기화

	a++;                  // a 값 1 증가
	printf("%d\n", a);   // a 출력
}

void static_func(void) {
	static int a;       // 정적 지역 변수 선언. 0으로 자동 초기화됨.

	a++;                // a 값 1 증가
	printf("%d\n", a); // a 출력
}
````
````
일반 지역 변수(auto)를 사용한 함수...
1
1
1
정적 지역 변수(static)를 사용한 함수...
1
2
3
````
#### 레지스터 변수
- 레지스터 변수 (register variable) : 블록 혹은 함수 내에서 변수를 선언할 때 register 예약어를 사용하면 레지스터 변수가 생성됨.
- 레지스터 변수는 CPU 안에 있는 저장 공간인 레지스터를 사용한다는 것이 가장 큰 특징이다!!
- 레지스터는 CPU 안에 있어 데이터 처리 속도가 가장 빠른 저장 공간이므로, 반복문에 쓰는 변수와 같이 사용 횟수가 많은 경우 레지스터에 할당하면 실행 시간을 줄일 수 있다.

<레지스터 변수 사용 시 주의점>
1. 전역 변수는 레지스터 변수로 선언할 수 없다.
2. 레지스터 변수는 포인터를 구할 수 없다.
3. 레지스터의 사용 여부는 컴파일러가 결정한다. 

````C
#include <stdio.h>

int main(void) {
	
	register int i;
	int sum = 0;

	for (i = 1; i <= 10000; i++) {
		sum += i;
	}

	printf("%d\n", sum);

	return 0;
}
````
````
50005000
````
